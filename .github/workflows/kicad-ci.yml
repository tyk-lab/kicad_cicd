# KiCad项目自动化构建工作流
# 功能：ERC/DRC检查、导出原理图PDF、BOM、Gerber文件和PCB图像
name: KiCad CI/CD

# 触发条件：推送到主分支或手动触发
on:
  push:
    branches:
      - main      # 主分支推送时触发
      - master    # 或master分支推送时触发
  workflow_dispatch:  # 允许在GitHub Actions页面手动触发

jobs:
  kicad-checks:
    runs-on: windows-latest  # 使用Windows平台运行
    
    steps:
      # 步骤1：检出代码仓库
      - name: Checkout repository
        uses: actions/checkout@v4
      
      # 步骤2：缓存KiCad安装
      - name: Cache KiCad installation
        id: cache-kicad
        uses: actions/cache@v4
        with:
          path: C:\Program Files\KiCad
          key: kicad-9.0.6-windows-${{ runner.os }}
          restore-keys: |
            kicad-9.0.6-windows-
      
      # 步骤3：检查KiCad是否已缓存
      - name: Check KiCad from cache
        id: check-kicad
        run: |
          $kicadCli = "C:\Program Files\KiCad\9.0\bin\kicad-cli.exe"
          if (Test-Path $kicadCli) {
            Write-Host "KiCad found in cache"
            echo "cached=true" >> $env:GITHUB_OUTPUT
          } else {
            Write-Host "KiCad not found, will install"
            echo "cached=false" >> $env:GITHUB_OUTPUT
          }
        shell: powershell
      
      # 步骤4：安装KiCad（仅在缓存未命中时）
      - name: Setup KiCad environment
        if: steps.check-kicad.outputs.cached == 'false'
        run: |
          Write-Host "Installing Visual C++ Redistributable..."
          # 安装必要的运行时库
          choco install vcredist-all -y
          
          Write-Host "Installing KiCad 9.0.6..."
          # 使用Chocolatey安装KiCad最新版本 9.0.6
          choco install kicad --version=9.0.6 -y
          
          Write-Host "KiCad installation completed"
        shell: powershell
      
      # 步骤4.5：配置环境变量
      - name: Configure KiCad PATH
        run: |
          # 将KiCad bin目录添加到当前会话的PATH
          $kicadBin = "C:\Program Files\KiCad\9.0\bin"
          $env:PATH = "$kicadBin;$env:PATH"
          
          # 同时添加到后续步骤的PATH
          echo "$kicadBin" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append
          
          Write-Host "KiCad added to PATH: $kicadBin"
          Write-Host "Current PATH: $env:PATH"
        shell: powershell
      
      # 步骤5：验证KiCad安装
      - name: Verify KiCad installation
        run: |
          Write-Host "Verifying KiCad installation..."
          
          # 检查kicad-cli.exe是否存在
          $kicadCli = "C:\Program Files\KiCad\9.0\bin\kicad-cli.exe"
          if (Test-Path $kicadCli) {
            Write-Host "Found kicad-cli.exe at: $kicadCli"
            
            # 显示版本信息
            Write-Host ""
            Write-Host "KiCad Version:"
            & $kicadCli version
          } else {
            Write-Host "kicad-cli.exe not found at: $kicadCli"
            Write-Host ""
            Write-Host "Searching for KiCad installation..."
            
            # 查找KiCad安装目录
            if (Test-Path "C:\Program Files\KiCad") {
              Get-ChildItem "C:\Program Files\KiCad" -Recurse -Filter "kicad-cli.exe" -ErrorAction SilentlyContinue | ForEach-Object {
                Write-Host "Found: $($_.FullName)"
              }
            }
            
            exit 1
          }
        shell: powershell
      
      # 步骤6：运行ERC检查（电气规则检查）
      # 检查原理图中的电气连接错误，如未连接的引脚、电源冲突等
      - name: Run ERC (Electrical Rules Check)
        continue-on-error: true
        run: |
          Write-Host "Starting ERC check..."
          
          # 检查原理图文件是否存在
          $schFile = "229_Test.kicad_sch"
          if (-not (Test-Path $schFile)) {
            Write-Host "Schematic file not found: $schFile"
            Write-Host ""
            Write-Host "Available .kicad_sch files:"
            Get-ChildItem -Filter "*.kicad_sch"
            exit 1
          }
          Write-Host "Found schematic file: $schFile"
          
          # 使用完整路径调用kicad-cli
          $kicadCli = "C:\Program Files\KiCad\9.0\bin\kicad-cli.exe"
          Write-Host ""
          Write-Host "Running ERC check with: $kicadCli"
          
          # 检查依赖的DLL是否存在
          $kicadBin = "C:\Program Files\KiCad\9.0\bin"
          if (Test-Path $kicadBin) {
            Write-Host "KiCad bin directory contents:"
            Get-ChildItem $kicadBin -Filter "*.dll" | Select-Object -First 5 | ForEach-Object { Write-Host "  $($_.Name)" }
          }
          
          try {
            & $kicadCli sch erc --format json --output erc_report.json $schFile 2>&1 | Write-Host
            $exitCode = $LASTEXITCODE
            
            if ($exitCode -eq 0) {
              Write-Host "ERC check completed successfully"
            } elseif ($exitCode -eq -1073741819) {
              Write-Host "ERROR: KiCad crashed (Access Violation - missing dependencies)"
              Write-Host "This may indicate missing Visual C++ Runtime or other dependencies"
            } else {
              Write-Host "ERC check completed with exit code: $exitCode"
            }
          } catch {
            Write-Host "ERC check failed: $_"
            Write-Host $_.Exception.Message
          }
          
          # 检查报告文件是否生成并输出内容
          if (Test-Path erc_report.json) {
            Write-Host ""
            Write-Host "ERC Report:"
            Write-Host "==========================================="
            Get-Content erc_report.json | Write-Host
            Write-Host "==========================================="
          } else {
            Write-Host "WARNING: ERC report file was not generated"
            # 创建一个空报告文件避免后续步骤失败
            '{"violations":[]}' | Out-File -FilePath erc_report.json -Encoding utf8
          }
        shell: powershell
      
      # 步骤7：运行DRC检查（设计规则检查）
      # 检查PCB设计中的布线错误，如间距不足、悬空走线等
      - name: Run DRC (Design Rules Check)
        continue-on-error: true
        run: |
          Write-Host "Starting DRC check..."
          
          # 检查PCB文件是否存在
          $pcbFile = "229_Test.kicad_pcb"
          if (-not (Test-Path $pcbFile)) {
            Write-Host "PCB file not found: $pcbFile"
            Write-Host ""
            Write-Host "Available .kicad_pcb files:"
            Get-ChildItem -Filter "*.kicad_pcb"
            exit 1
          }
          Write-Host "Found PCB file: $pcbFile"
          
          # 使用完整路径调用kicad-cli
          $kicadCli = "C:\Program Files\KiCad\9.0\bin\kicad-cli.exe"
          Write-Host ""
          Write-Host "Running DRC check with: $kicadCli"
          
          try {
            & $kicadCli pcb drc --format json --output drc_report.json $pcbFile
            $exitCode = $LASTEXITCODE
            
            if ($exitCode -eq 0) {
              Write-Host "DRC check completed successfully"
            } else {
              Write-Host "DRC check completed with warnings/errors (exit code: $exitCode)"
            }
          } catch {
            Write-Host "DRC check failed: $_"
            Write-Host $_.Exception.Message
            exit 1
          }
          
          # 检查报告文件是否生成并输出内容
          if (Test-Path drc_report.json) {
            Write-Host ""
            Write-Host "DRC Report:"
            Write-Host "==========================================="
            Get-Content drc_report.json | Write-Host
            Write-Host "==========================================="
          } else {
            Write-Host "WARNING: DRC report file was not generated"
            # 创建一个空报告文件避免后续步骤失败
            '{"violations":[]}' | Out-File -FilePath drc_report.json -Encoding utf8
          }
        shell: powershell
      
      # 步骤8：导出原理图为PDF文档
      - name: Export Schematic PDF
        run: |
          Write-Host "Exporting schematic to PDF..."
          # 创建输出目录
          New-Item -ItemType Directory -Force -Path outputs
          # 将原理图导出为PDF格式，方便查看和打印
          $kicadCli = "C:\Program Files\KiCad\9.0\bin\kicad-cli.exe"
          & $kicadCli sch export pdf --output outputs/229_Test-Schematic.pdf 229_Test.kicad_sch
          Write-Host "Schematic PDF exported"
        shell: powershell
      
      # 步骤6：导出BOM（物料清单）
      - name: Export BOM
        run: |
          Write-Host "Exporting BOM..."
          # 从原理图导出BOM清单（CSV格式），包含所有元件信息
          $kicadCli = "C:\Program Files\KiCad\9.0\bin\kicad-cli.exe"
          & $kicadCli sch export bom --output outputs/229_Test-BOM.csv 229_Test.kicad_sch
          Write-Host "BOM exported"
        shell: powershell
      
      # 步骤7：生成Gerber制造文件
      - name: Generate Gerber files
        run: |
          Write-Host "Generating Gerber files..."
          # 创建Gerber输出目录
          New-Item -ItemType Directory -Force -Path outputs/gerber
          $kicadCli = "C:\Program Files\KiCad\9.0\bin\kicad-cli.exe"
          
          # 导出所有Gerber层文件（用于PCB制造）
          & $kicadCli pcb export gerbers --output outputs/gerber/ 229_Test.kicad_pcb
          Write-Host "Gerber layers exported"
          
          # 生成钻孔文件（Excellon格式）
          & $kicadCli pcb export drill --format excellon --output outputs/gerber/ 229_Test.kicad_pcb
          Write-Host "Drill files generated"
        shell: powershell
      
      # 步骤8：导出PCB可视化图像
      - name: Export PCB images
        run: |
          Write-Host "Exporting PCB images..."
          $kicadCli = "C:\Program Files\KiCad\9.0\bin\kicad-cli.exe"
          
          # 导出PCB正面视图（SVG格式）
          # 包含正面铜层、阻焊层、丝印层和板框
          & $kicadCli pcb export svg --output outputs/229_Test-PCB-Front.svg --layers F.Cu,F.Mask,F.Silkscreen,Edge.Cuts 229_Test.kicad_pcb
          Write-Host "Front PCB image exported"
          
          # 导出PCB背面视图（SVG格式）
          # 包含背面铜层、阻焊层、丝印层和板框
          & $kicadCli pcb export svg --output outputs/229_Test-PCB-Back.svg --layers B.Cu,B.Mask,B.Silkscreen,Edge.Cuts 229_Test.kicad_pcb
          Write-Host "Back PCB image exported"
          
          # 尝试导出3D STEP模型（如果可用）
          # 失败时不中断工作流
          try {
            & $kicadCli pcb export step --output outputs/229_Test-3D.step 229_Test.kicad_pcb
            Write-Host "3D STEP model exported"
          } catch {
            Write-Host "3D export skipped (may require 3D models)"
          }
        shell: powershell
      
      # 步骤9：打包Gerber文件为ZIP压缩包
      - name: Create Gerber ZIP archive
        run: |
          # 将所有Gerber文件打包，方便下载和提交给PCB厂商
          Compress-Archive -Path outputs/gerber/* -DestinationPath outputs/229_Test-Gerber.zip -Force
        shell: powershell
      
      # 步骤10：上传构建产物到GitHub Artifacts
      # 可在Actions页面下载，保留90天
      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: kicad-outputs
          path: outputs/
      
      # 步骤11：生成构建摘要文档
      - name: Update README with status
        run: |
          # 创建包含构建信息的Markdown摘要文件
          # 该文件将被用作Release的说明
          $buildDate = (Get-Date).ToUniversalTime().ToString("yyyy-MM-dd HH:mm:ss UTC")
          $cacheStatus = if ('${{ steps.cache-kicad.outputs.cache-hit }}' -eq 'true') { 'Used cached installation' } else { 'Fresh installation' }
          @"
          ## Build Summary
          
          - **Build Date**: $buildDate
          - **Commit**: ${{ github.sha }}
          - **Branch**: ${{ github.ref_name }}
          - **KiCad Setup**: $cacheStatus
          
          ### Outputs
          
          - ✅ Schematic PDF
          - ✅ BOM (Bill of Materials)
          - ✅ Gerber files
          - ✅ PCB Images (SVG)
          
          "@ | Out-File -FilePath outputs/build_summary.md -Encoding utf8
        shell: powershell
      
      # 步骤12：创建GitHub Release并上传所有文件
      # 仅在推送到主分支时执行（手动触发时不创建Release）
      - name: Create Release
        if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master')
        uses: softprops/action-gh-release@v1
        with:
          tag_name: build-${{ github.run_number }}          # 使用构建编号作为标签
          name: Build ${{ github.run_number }}              # Release标题
          body_path: outputs/build_summary.md               # Release说明内容
          files: |                                           # 要上传的文件列表
            outputs/229_Test-Schematic.pdf
            outputs/229_Test-BOM.csv
            outputs/229_Test-Gerber.zip
            outputs/229_Test-PCB-Front.svg
            outputs/229_Test-PCB-Back.svg
            outputs/229_Test-3D.step
            erc_report.json
            drc_report.json
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}         # 使用GitHub提供的访问令牌
